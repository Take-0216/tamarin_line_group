theory line_group_v2_active_e2e_analysis
begin

// ==========================================================
// 1. 基本設定・暗号プリミティブ
// ==========================================================
builtins: diffie-hellman
// v2: AES-GCM (Msg, AAD, Key, Nonce) 
functions: aenc/4, adec/4, kdf/2, pair/2

// AES-GCM の性質定義
equations:
  adec(aenc(m, aad, k, n), aad, k, n) = m 

restriction OnlyOneInit:
  "All #i #j. OnlyOnce() @ #i & OnlyOnce() @ #j ==> #i = #j"

restriction Equality:
  "All x y #i. Eq(x,y)@i ==> x=y"

// ==========================================================
// 2. ユーザー初期化と公開鍵登録
// ==========================================================

rule Init:
  [ Fr(~aID), Fr(~skA), Fr(~bID), Fr(~skB), Fr(~cID), Fr(~skC) ]
  --[ InitUsers(~aID, ~bID, ~cID), OnlyOnce() ]->
  [ !InitA(~aID, ~skA), !InitB(~bID, ~skB), !InitC(~cID, ~skC) ]

rule RegisterPKs:
  [ !InitA(~aID, ~skA), !InitB(~bID, ~skB), !InitC(~cID, ~skC) ]
  --[ PKRegisteredA(~aID, 'g'^~skA), PKRegisteredB(~bID, 'g'^~skB), PKRegisteredC(~cID, 'g'^~skC) ]-> 
  [ !KeyServerA(~aID, 'g'^~skA), !KeyServerB(~bID, 'g'^~skB), !KeyServerC(~cID, 'g'^~skC) ] 

// ==========================================================
// 3. 鍵配布 (Aが共有鍵~GKを生成し配布)
// ==========================================================

rule A_Distribute_GK:
  let 
    // 修正: Aは相手の秘密鍵(~skB)を知らないため、サーバーの公開鍵(pkB)を使ってECDHを行う
    ssAB = pkB ^ ~skA
    ssAC = pkC ^ ~skA 
  in
  [ !InitA(~aID, ~skA), !KeyServerB(~bID, pkB), !KeyServerC(~cID, pkC), Fr(~GK) ]
  --[ GroupSecretEstablished(~aID, ~GK) ]->
  [ !GroupKeyA(~aID, ~GK), 
    Out(aenc(~GK, 'aad', ssAB, 'n1')), 
    Out(aenc(~GK, 'aad', ssAC, 'n2'))
  ]

rule B_Receives_GK:
  let ssBA = pkA ^ ~skB
      gk = adec(encGK, 'aad', ssBA, 'n1') in
  [ !InitB(~bID, ~skB), !KeyServerA(~aID, pkA), In(encGK) ]
  --[ GroupSecretEstablished(~bID, gk) ]->
  [ !B_Has_GK(~bID, gk) ]

rule C_Receives_GK:
  let ssCA = pkA ^ ~skC
      gk = adec(encGK, 'aad', ssCA, 'n2') in
  [ !InitC(~cID, ~skC), !KeyServerA(~aID, pkA), In(encGK) ]
  --[ GroupSecretEstablished(~cID, gk) ]->
  [ !C_Has_GK(~cID, gk) ]

// ==========================================================
// 4. メッセージ送信 (Bが送信者)
// ==========================================================

rule B_Sends_Message:
  let sgk = kdf(gk, ~salt)
      metadata = <~bID, 'gID'> // AADとして使用
      nonce = <~counter, ~rand>
      ct = aenc(~m, metadata, sgk, nonce) in
  [ !B_Has_GK(~bID, gk), Fr(~m), Fr(~salt), Fr(~counter), Fr(~rand) ]
  --[ SentB(~bID, ~m, ~salt), Honest(~bID) ]->
  [ Out(<metadata, <ct, ~salt, nonce>>) ]

// ==========================================================
// 5. メッセージ受信 (AとCが受取人)
// ==========================================================

rule A_Receives_Message:
  let metadata = <senderInMetadata, 'gID'>
      sgk = kdf(~GK, salt)
      m = adec(ct, metadata, sgk, nonce) in
  [ !GroupKeyA(~aID, ~GK), In(<metadata, <ct, salt, nonce>>) ]
  --[ AReceived(senderInMetadata, m, salt, ct), Eq(m, m) ]-> []

rule C_Receives_Message:
  let metadata = <senderInMetadata, 'gID'>
      sgk = kdf(gk, salt)
      m = adec(ct, metadata, sgk, nonce) in
  [ !C_Has_GK(~cID, gk), In(<metadata, <ct, salt, nonce>>) ]
  --[ CReceived(senderInMetadata, m, salt, ct), Eq(m, m) ]-> []

// ==========================================================
// 6. 攻撃者モデル (アクティブな改竄と鍵漏洩)
// ==========================================================

rule Reveal_LTK:
  [ !InitA(id, sk) ] --[ Revealed(id) ]-> [ Out(sk) ]

rule Attacker_Manipulates_Header:
  [ In(< <sender, gID>, payload >), Fr(~fakeSender) ]
  --[ ManipulatedHeader(sender, ~fakeSender) ]->
  [ Out(< <~fakeSender, gID>, payload >) ]

// ==========================================================
// 7. 検証用 Lemma
// ==========================================================

lemma protocol_is_executable_full_run:
  exists-trace "Ex sender m salt ct #i. CReceived(sender, m, salt, ct) @ i"

lemma pki_soundness:
  "All aID pkA #i #j. PKRegisteredA(aID, pkA) @ i & PKRegisteredA(aID, pkA) @ j ==> #i = #j"

// 内容の完全性 (Verified期待)
lemma authenticity_message_only_C:
  "All sInMeta m salt ct #i.
      CReceived(sInMeta, m, salt, ct) @ #i
    ==> ( (Ex anySender #j. SentB(anySender, m, salt) @ #j & j < i) 
        | (Ex uID #k. Revealed(uID) @ #k) )"

// 秘匿性 (Verified期待)
lemma message_secrecy:
  "All bID m salt #i. SentB(bID, m, salt) @ #i & Honest(bID) @ #i
    ==> not (Ex #j. K(m) @ #j) | (Ex uID #k. Revealed(uID) @ #k)"

// リプレイ耐性 (A) - 引数を4つに修正
lemma replay_protection_A:
  "All s m salt ct #i #j. AReceived(s, m, salt, ct) @ i & AReceived(s, m, salt, ct) @ j ==> #i = #j"

// リプレイ耐性 (C)
lemma replay_protection_C:
  "All s m salt ct #i #j. CReceived(s, m, salt, ct) @ i & CReceived(s, m, salt, ct) @ j ==> #i = #j"

// 前方秘匿性 (Verified期待: ECDHを介しているため)
lemma forward_secrecy_of_group_key:
  "All userID gk #i. GroupSecretEstablished(userID, gk) @ #i
    ==> ( not(Ex #k. K(gk) @ #k) | (Ex id #r. Revealed(id) @ #r & r < i) )"

// 後方秘匿性 (Verified期待: 長期鍵が漏洩しても未来のセッションのGKは計算できない)
lemma backward_secrecy_of_future_messages:
  "All bID m salt #i #j uID. Revealed(uID) @ #j & #j < #i & SentB(bID, m, salt) @ #i & Honest(bID) @ #i
    ==> not(Ex #k. K(m) @ #k)"

// メタデータの改竄検知 (Verified期待: v2のAAD保護)
lemma authenticity_A_from_sender:
  "All sender m salt ct #i.
      AReceived(sender, m, salt, ct) @ #i
    ==> ( (Ex #j. SentB(sender, m, salt) @ #j & j < i) | (Ex uID #k. Revealed(uID) @ #k) )"

lemma group_model_sanity_check:
  exists-trace "Ex sender m salt ct #i #j bID. CReceived(sender, m, salt, ct) @ #i & SentB(bID, m, salt) @ #j"

end